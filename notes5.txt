now we will start making the dash board----


first we will start making the useUseAuth.jsx in hooks ---
then i have called this in the userdashboard .jsx

ðŸ§­ What Happens Here
As soon as UserDashboard mounts:

useUserAuth checks if the user is authenticated.
If not, it redirects to the login page.
If the user is valid, the dashboard loads normally.

âœ… When to Use	
In any component (like dashboards, profiles) that should only be visible to logged-in users



------------------
now lets focus on the navbar or sidemenu for both admin and user

first in dashboard we check is user is authenticated or not for that we will make a hook named useUserAuth
and will call this in the dashboard 



useUserAuth: a custom hook that likely checks if a user is authenticated.
UserContext: provides the current logged-in user.
DashboardLayout: a reusable layout that wraps around pages like a template.

The layout will render:

Navbar
SideMenu (if user exists)
This "Dashboard" text in the content area


now in useUserAuth()---

You import useEffect to perform side effects (like redirecting).

useContext is used to get the user, loading, and clearUser from the UserContext.

useNavigate from react-router-dom is used for programmatic navigation (e.g., redirect to login).


export const useUserAuth = () => {
    const {user, loading, clearUser} = useContext(UserContext);
    const navigate = useNavigate();

    useEffect(() => {
        if (loading) return; // Wait if user state is still being fetched

        if (!user) {
            clearUser();       // Clean up any existing user data
            navigate("/login"); // Redirect to login page
        }
    }, [user, loading, clearUser, navigate]); // Trigger the effect on change
}

const { user, loading, clearUser } = useContext(UserContext);

| Variable    | What it does                                                                                      |
| ----------- | ------------------------------------------------------------------------------------------------- |
| `user`      | The current logged-in user. Will be `null` if not logged in.                                      |
| `loading`   | Boolean that tells if the user data is still loading (e.g., from local storage or API).           |
| `clearUser` | A function you wrote in the context to clear/reset user data (used on logout or invalid session). |


useEffect(() => {
  if (loading) return;

  if (!user) {
    clearUser();
    navigate("/login");
  }
}, [user, loading, clearUser, navigate]);----------------------

This effect runs every time any of the dependencies in the array change â€” so when:
user is updated
loading becomes false (usually after fetching the user)
clearUser or navigate change (they usually donâ€™t)


if (loading) return;--------
This ensures that you donâ€™t check user until the app is done fetching/loading the user info.
Prevents redirecting to login prematurely.
Example: If your app is fetching user info from localStorage or Firebase, this prevents the hook from reacting too early.

if (!user) {
  clearUser();
  navigate("/login");
}-----------------
If the user is not authenticated:
clearUser() is called â€” this can clear user data from context, localStorage, etc.
navigate("/login") is used to redirect the user to the login page.



NOw in dashboard userAuth is called and understood what it does now lets see dashboardlayout wrappper
dashboardLayout---


const DashboardLayout = ({children,activeMenu}) => {
    const {user}=useContext(UserContext)
  return (
    <div className=''>
        <Navbar activeMenu={activeMenu}/>

        {user && (
            <div className='flex'>
                <div className='max-[1080px]:hidden'>
                    <SideMenu activeMenu={activeMenu} />
                </div>

                <div className='grow mx-5'>{children}
                
                </div>
                </div>
        )}
       
    </div>
  )
}

âœ… Purpose of DashboardLayout
Itâ€™s a layout wrapper used in pages like your dashboard to:

Show the navbar at the top.
Show the sidebar (SideMenu) on the left.
Render the actual page content (children) on the right.
Only display content if the user is logged in (based on context).


const { user } = useContext(UserContext)----
You access the current logged-in user from global context.
This ensures that the layout will only render if a user is authenticated.
Without a user, nothing inside the layout (navbar/sidebar/content) is shown.

<Navbar activeMenu={activeMenu} />----------

The top navigation bar is always shown.
You pass activeMenu to highlight the current section in the mobile view.

{user && ( <div className='flex'> ... </div> )}-----------

The sidebar and main content are only shown if user is not null.
Prevents unauthorized users from seeing dashboard content.

<div className='max-[1080px]:hidden'>
  <SideMenu activeMenu={activeMenu} />
</div>-----------------------------------------


Sidebar is hidden on screens smaller than 1080px using Tailwind (max-[1080px]:hidden).
It receives activeMenu to highlight the current menu item.


<div className='grow mx-5'>
  {children}
</div>-------------------------

The main area where the actual page content (like dashboard, tasks, etc.) goes.
children is a special React prop that allows you to render nested elements inside a layout.

âœ… This allows you to use DashboardLayout like this:
<DashboardLayout activeMenu="dashboard">
  <h1>Dashboard</h1>
</DashboardLayout>



+-------------------------------------------------------------+
|                          Navbar                             |
+------------------------+------------------------------------+
|       Sidebar          |             Page Content           |
|  (Hidden on mobile)    |      (Rendered via {children})     |
+------------------------+------------------------------------+



now in dashboardLayout navbar and sidemenu are also wrapper layout sp let see that 


Navbar-------



const [openSideMenu, setOpenSideMenu] = useState(false);
const [activeMenu, setActiveMenu] = useState('dashboard');


openSideMenu: true or false to show/hide sidebar on small screens.
activeMenu: tracks the currently active menu item â€” passed to SideMenu


1. Navbar Wrapper
<div className='flex gap-5 bg-white border-b border-gray-200/50 backdrop-blur-[2px] py-4 px-7 items-center'>


A flex container to horizontally align items.
White background, subtle bottom border, and backdrop blur for a nice glass effect.
Padding for spacing.


2. Menu Toggle Button (Visible on Mobile Only)
jsx
Copy
Edit
<button 
  className='block lg:hidden text-black'
  onClick={() => setOpenSideMenu(!openSideMenu)}
>
  {openSideMenu ? ( 
    <HiOutlineX className="text-2xl" />
  ) : (
    <HiOutlineMenu className="text-2xl" />
  )}
</button>

block lg:hidden: Visible on mobile (lg:hidden hides it on large screens).
Toggles openSideMenu when clicked.
Displays X (close) icon if open, otherwise hamburger (menu) icon.


3. Navbar Title

<h2 className='text-lg font-medium text-black'>Expense Tracker</h2>
Center title for branding or identifying the current module.

4. Conditional Mobile Sidebar
jsx
Copy
Edit
{openSideMenu && ( 
  <div className='fixed top-[61px] left-0 w-full bg-white z-50'>
    <SideMenu activeMenu={activeMenu} />
  </div>
)}
If openSideMenu is true:
Shows a fixed SideMenu below the navbar (top-[61px] aligns it right below the navbar height).
z-50 ensures it appears above everything else.
Covers the full width (w-full) of the screen.


SideMenu---------------------------

import React, { useContext, useState,useEffect } from 'react'
import { UserContext } from '../../context/userContext'
import { useNavigate } from 'react-router-dom';
import { SIDE_MENU_DATA, SIDE_MENU_USER_DATA } from '../../utils/data';

const SideMenu = ({activeMenu}) => {
    const {user,clearUser}=useContext(UserContext);
    const[SideMenuData,setSideMenuData]=useState([]);

    const navigate=useNavigate();

    const handleClick=(route)=>{
        if(route==="logout")
        {
            handleLogout();
            return;
        }

        navigate(route);
    };

    const handleLogout=()=>{
        localStorage.clear();
        clearUser();
        navigate("/login");
        
    };

    useEffect(()=>{
        if(user)
        {
            setSideMenuData(user?.role === "admin" ? SIDE_MENU_DATA:SIDE_MENU_USER_DATA)
        }
        return () =>{};
    },[user]);
  return (
    <div>
        SideMenu
      
    </div>
  )
}



import React, { useContext, useState, useEffect } from 'react';
import { UserContext } from '../../context/userContext';
import { useNavigate } from 'react-router-dom';
import { SIDE_MENU_DATA, SIDE_MENU_USER_DATA } from '../../utils/data';

ðŸ” 1. Imports and Context Setup
useContext(UserContext) gives access to:
     user â†’ current logged-in user object.
     clearUser() â†’ clears user data from context.
useNavigate() â†’ for programmatic navigation.
SIDE_MENU_DATA and SIDE_MENU_USER_DATA â†’ arrays containing menu options for admin and regular users.

âš™ï¸ 2. State Management
const [SideMenuData, setSideMenuData] = useState([]);
This state stores the appropriate menu list based on the role of the logged-in user.

ðŸ§  3. useEffect: Decide Which Menu to Show

useEffect(() => {
  if (user) {
    setSideMenuData(user?.role === "admin" ? SIDE_MENU_DATA : SIDE_MENU_USER_DATA);
  }
  return () => {};
}, [user]);

Runs whenever user changes.
If user.role === "admin" â†’ show admin menu.
Otherwise â†’ show regular user menu

ðŸ”˜ 4. Navigation Handlingconst handleClick = (route) => {
  if (route === "logout") {
    handleLogout();
    return;
  }

  navigate(route);
};

const handleLogout = () => {
  localStorage.clear();
  clearUser(); // clears from context
  navigate("/login");
};


Clicking "Logout" clears local storage, context, and redirects to /login.
Otherwise, navigates to the given route.
---------------------------------------------------