dotenv--
   dotenv is a package that loads environment variables from a .env file into process.env. It's useful for managing API keys, database credentials, and other sensitive configurations.

⚠️ Important Notes
Variables MUST start with VITE_ in React/Vite (e.g., VITE_API_KEY)

Do NOT commit .env files (add it to .gitignore)

Environment variables are exposed to the frontend (not secure for sensitive data)


require("dotenv").config();
------------------------------------------------------------------------------------------------

cors------------------------
   CORS (Cross-Origin Resource Sharing) is a security feature in web browsers that restricts requests made from one domain (frontend) to another domain (backend). If your React frontend is trying to fetch data from a different origin (e.g., localhost:5173 to localhost:5000), you might get a CORS error.

Use CORS Middleware in server.js--------------------------
const express = require("express");
const cors = require("cors");

const app = express();

// Enable CORS for all requests
app.use(cors());

// OR Enable CORS for specific origins
app.use(
  cors({
    origin: "http://localhost:5173", // React app URL
    methods: "GET,POST,PUT,DELETE",
    credentials: true,
  })
);

app.get("/api/data", (req, res) => {
  res.json({ message: "CORS is working!" });
});

app.listen(5000, () => console.log("Server running on port 5000"));




****Defining User MongoDB Schema---------
****
✅ role ensures role-based access control (RBAC).
✅ timestamps keeps track of record creation & updates.
✅ Reduces manual work (no need to set createdAt and updatedAt manually).\


mongoose.model("User", userSchema)
mongoose.model() is a function that creates a Mongoose model from a schema.

First Argument ("User"): The name of the collection (Mongoose automatically converts it to users in MongoDB).


module.exports=mongoose.model("User,userSchema");----------------------------------------------------------------
Second Argument (userSchema): The schema that defines the structure of the documents.

✅ Step 2: module.exports = ...
module.exports is a Node.js feature that allows us to export this model so that it can be used in other files.

4️⃣ Why Use module.exports?
✅ Allows the User model to be used in other files.
✅ Ensures separation of concerns (schema & logic are in different files).
✅ Supports scalability (can define multiple models & use them across the app).



**Defining Task MongoDB Schema------**

{}---Defines objects (single values with properties)
[]--Defines arrays (lists of elements)

Creating Authentication APIs (Login, Sign-Up, Get User Info, Profile Image Upload)--------------------------------


1. first create all the route in the authroutes and then move authmiddleware for creation
in authroutes--

const router = express.Router();\
Creates a new router instance using express.Router().
This router will handle all authentication-related routes.
Instead of defining routes in server.js, we modularize them in authRoutes.js.



router.get("/profile", protect, getUserProfile);
router.put("/profile", protect, updateUserProfile);
Only logged-in users with a valid token can access the /profile route.
The protect middleware ensures that the request has a valid JWT before calling getUserProfile or updateUserProfile


module.exports = router;
✅ Purpose:
Exports the router so that it can be used in server.js or another route file.
Allws us to use app.use("/api/auth", require("./routes/authRoutes")) in the main server file.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Now  we  will create jwt for private routes from unauthorized users for this we will create thisin the authmiddleware


🌟 What is JWT Authentication?---->
JWT (JSON Web Token) authentication is a way to secure API routes by verifying user identity with a token-based system. It is widely used in authentication systems to:

purpose:-->

1.Protect routes from unauthorized users.
2.Verify users without storing session data.
3.Enable secure API communication between frontend and backend.

🛠 How JWT Authentication Works?--->

1.User Registers or Logs In → Backend issues a JWT token.
2.Frontend Stores the Token (in localStorage or httpOnly cookie).
3.User Makes API Requests → The token is sent in the request headers.
4.Backend Verifies the Token → If valid, it allows access to protected routes.


In middlewares/authMiddleware.js, create a middleware to protect routes:------>

1.Extracts the JWT token from the request headers.
2.Verifies if the token is valid.
3.Fetches user details from the database (excluding password).
4.Attaches user data to req.user.
5.Proceeds to the next middleware if authentication is successful.


let token = req.headers.authorization;--------->
This line extracts the Authorization header from the incoming HTTP request.


if (req.headers.authorization && req.headers.authorization.startsWith("Bearer")) ---->
 
  The JWT token is sent in the Authorization header as:
  Authorization: Bearer <token>
  This checks if the header exists and if it starts with "Bearer".

1.Extract the Token------>

token = req.headers.authorization.split(" ")[1];-->>

The Authorization header contains "Bearer <token>".

Splitting it by a space (" ") extracts the token.

"Bearer abc123xyz"
After split(" "), it becomes:

["Bearer", "abc123xyz"]
We take index 1 ("abc123xyz"), which is the token.

2.Verify the Token----->

const decoded=jwt.verify(token,process.env.JWT_SECRET);---->

jwt.verify(token, secret) checks if the token is valid.
and the token is tored in the environement variable.
If valid, it decodes the user ID stored in the token.

3.etch the User from Database---->

req.user=await User.findById(decoded.id).select("-password");---->

Finds the user by the decoded ID.
.select("-password") means the password field is excluded for security reasons.
The resulting user object is attached to req.user so it can be used later in the route handler.


4.Proceed to Next Middleware--->

next();---->

If authentication is successful, the request proceeds to the actual route handler (e.g., getUserProfile).
Without calling next(), the request would hang.

else { res.status(401).json({ message: "Not Authorized, no token found" }); }------>

  If the token is missing or doesn't start with "Bearer", the server sends a 401 Unauthorized error.

catch (error) { res.status(401).json({ message: "Token Failed", error: error.message }); }----->

 json is used Because APIs (especially REST APIs) talk in JSON — it's the standard language that frontend and backend use to exchange data. 
a.If anything goes wrong in the try block (e.g., invalid token, expired token, corrupted token), this catch block:
b.Catches the error,
c.Sends a 401 Unauthorized status,
d.Includes the error message for debugging


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Middleware for admin Only

const adminOnly=(req,res,next) =>
{
    if(req.user && req.user.role == 'admin')
{
    next();  //pass control to the next middleware
}   
     else{
        return res.status(403).json({message:"Access Denied: Admins Only"});
     }
};
module.exports = protect;


In this it checks the user is admin or not if it is admin then it will give the access through next() or we can say pass to the next middleware.



----------------------------- --------------------------------------------------------------------------------------------------------------------------------
FOR REGISTERING THE USER---

1.const registerUser = async (req, res) => {

  (req, res): Express automatically passes these parameters.
req: Represents the HTTP request (contains data like headers, body, params).
res: Represents the HTTP response (used to send data back to client).


2.const { name, email, password, profileImageUrl, adminInviteToken } = req.body;

Extracting properties sent in the body of the request. This keeps code cleaner than accessing req.body.name, etc., individually.


3.if (!name || !email || !password) {
    return res.status(400).json({ message: "Please fill all the fields" });
}

Checks if any of these fields are missing.
400 status: Bad Request.
return: Stops execution and sends response immediately.


4.const extistingUser = await User.findOne({ email });
if (extistingUser) {
    return res.status(400).json({ message: "User already Exists" });
}

User.findOne({ email }): Searches MongoDB for any document with the same email.
Prevents duplicate user accounts with same email.

5.let role = "member";
if (adminInviteToken && adminInviteToken == process.env.ADMIN_INVITE_TOKEN) {
    role = "admin";
}

By default, every user is a "member".
If the user supplies a correct adminInviteToken (defined in .env), their role is set to "admin".

6.const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);

bcrypt.genSalt(10): Creates a cryptographic salt with 10 rounds (strength).
bcrypt.hash(password, salt): Hashes the password with the generated salt.



hashing---->
.A salt is a random string added to your password before hashing it.
higher = more secure but slower.
.what bcrypt does behind the scenes:
Generates a random salt internally.
Adds it to your password.
Hashes the result.

7.const newUser = await User.create({
    name,
    email,
    passowrd: hashedPassword,
    profileImageUrl,
    role,
});

User.create(): Adds a new document to the MongoDB User collection.
Stores hashed password and other user info.

7.res.status(201).json({
    _id: user._id,
    name: user.name,
    email: user.email,
    role: user.role,
    profileImageUrl: user.profileImageUrl,
    token: generateToken,
});

Sends back important user data.

8.
catch(error) {
    res.status(500).json({ message: "server error", error: error.message });
}

Handles any errors thrown during registration (DB issues, bcrypt errors, etc.)
500: Internal Server Error.

--------------------------------------------------------------------------------------------------------------------

Login the user

1.check if email and password are provided
2.find the user via email
3.if the user do not exists then give the message otherwise comapre the hashed password with the passowrd givenand 
uf the password matches then return the user details with the token otherwise return the error message


--------------------------------------------------------------------------------------------------------------------
 gettinguserprofile-

 1.check if the user exists and find it through the userid

 2.if exists then return json(user)

 --------------------------------------------------------------------------------------------------------------------

updatinguserprofile--
1 find the user thorugh the user.id
2.then update the name,email,profileImageUrl like:
 user.name= req.body.name || user.name
 similoarly for the otherwise

 for password first check if new password is sent in the request -- 
 if(req.body.password)
 and then update it with the hashed password and store it in the user.password

 user.save()
 saves the upadated user object to MongoDB

 return the response with the upadted user object
  res.status(200).json({
            _id: updateUser._id,
            name: updateUser.name,
            email: updateUser.email,
            role: updateUser.role,
            profileImageUrl: updateUser.profileImageUrl,
            token: generateToken(updateUser._id),
        });



In this only we have to upload the image so first of all we have to create a upload route and then use multer to upload


🧱 First: What's Needed for Image Upload?

Multer middleware: used to handle multipart/form-data (which is used for uploading files).
An uploads folder where your images are saved.
Static file serving in Express to expose that folder.
A route like /upload-image to handle the file upload.
Frontend or Postman: to send a file through a form or request.

in auth routes or create new route
router.post("/upload-image", upload.single("image"), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file Uploaded" });
  }

  const imageUrl = `${req.protocol}://${req.get("host")}/uploads/${req.file.filename}`;
  res.status(200).json({ imageUrl });
});



upload.single("image")
1.upload: is the middleware function from Multer you configure.

.single("image"): tells Multer:---->
Accept only one file
Look for the file in the field named "image" in the form

<input type="file" name="image" /> ----->

const imageUrl = `${req.protocol}://${req.get("host")}/uploads/${req.file.filename}`;------------>

✅ ${...} — Template Literal (String Interpolation)
This is a template string in JavaScript.
It allows embedding variables inside strings using ${}.


e.g
const name = "Vaibhav";
console.log(`Hello, ${name}!`); // Output: Hello, Vaibhav!

req.protocol--->
This returns the protocol used in the request.
Usually, it’s:
"http" for localhost or non-secure sites.
"https" for secure connections (like in production).

req.get("host")--->
req.get() is used to access request headers.
"host" refers to the Host header, which gives the domain + port
On localhost, this usually returns something like:
"localhost:8000"


So combining req.protocol and req.get("host") gives:

http://localhost:8000



req.file.filename---->
1712345678912-profile.png


http://localhost:8000/uploads/1712345678912-profile.png

--------------------------------

now in the upload middleware function
🧠 What is Multer?
1.Multer is a middleware for handling multipart/form-data.
2.It’s primarily used for uploading files (like images, PDFs, etc.)
3.In your code, you're using disk storage, which means you're saving files directly on your server.



const multer = require("multer");
const path = require("path");

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/"); // Save files in uploads folder
  },
  filename: (req, file, cb) => {
    const uniqueName = Date.now() + "-" + file.originalname;
    cb(null, uniqueName); // e.g., 171231231-profile.png
  },
});

const storage = multer.diskStorage({...});------>

This tells Multer **where and how** to save uploaded files.

- You are setting **two key options** inside this function:
  - `destination`: Where to save files (folder)
  - `filename`: What name to give to each uploaded file

destination: (req, file, cb) => {----->

req: Incoming HTTP request
file: The file being uploaded (contains name, type, size)
cb: Callback function to tell multer where to save the file

📌 cb(null, "uploads/"):------->

null means no error
"uploads/" is the folder where files will be stored
It MUST exist. If it doesn’t, create it manually or use fs.mkdirSync().


filename: (req, file, cb) => {
  const uniqueName = Date.now() + "-" + file.originalname;
  cb(null, uniqueName);
}

file.originalname: Original name of the uploaded file (e.g., profile.png)
Date.now(): Adds a timestamp to make filename unique (avoids overwriting)

👀 So if someone uploads:
myphoto.png → it will be saved as: 1712391271239-myphoto.png


After upload, Multer creates a req.file object like this:
{
  "fieldname": "image",
  "originalname": "pic.jpg",
  "encoding": "7bit",
  "mimetype": "image/jpeg",
  "destination": "uploads/",
  "filename": "1712391271239-pic.jpg",
  "path": "uploads/1712391271239-pic.jpg",
  "size": 102400
}


const upload = multer({ storage });
This creates an upload handler middleware using the storage config.

Now you can use:
upload.single("image"): For uploading one file
upload.array("images", 5): For multiple
upload.fields([{ name: "avatar", maxCount: 1 }, ...])

Add File Type Validation-------------------->
const upload = multer({ 
  storage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (ext !== '.jpg' && ext !== '.png' && ext !== '.jpeg') {
      return cb(new Error("Only images are allowed"));
    }
    cb(null, true);
  }
});


  const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;

Regular expression to allow certain file extensions and MIME types.


const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());----->

path.extname(file.originalname): gets file extension, e.g., .png
.toLowerCase() ensures it matches lowercase types like .jpg
file.mimetype: a safer way to validate type (e.g.,image/jpeg, image/png)
allowedTypes.test(...): checks if extension/type is allowed.



if (extname && mimetype) {
    cb(null, true); // Accept the file
  } else {
    cb(new Error("Only image files are allowed!"));


✅ If both match:
cb(null, true): accept the file.

❌ If not:
cb(new Error("Only image files are allowed!")): reject and send error.


const upload = multer({ 
  storage,
  fileFilter 
});


storage: Where to store the file and how to name it.
fileFilter: To restrict uploads only to images.
upload is now your custom middleware.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



.